# 常见的 web 安全问题和解决方法

## 同源策略

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。

1. 同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。

2. 同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。

3. 同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

解决同源策略的方法：

1. 跨文档消息机制: 可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

2. 跨域资源共享（CORS）: 跨域资源在服务端设置允许跨域，就可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

3. 内容安全策略（CSP）: 主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等等），而非白名单的内容无法正常执行。

## XSS，跨站脚本攻击(Cross Site Scripting)

### 反射型 XSS

<非持久化>

攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发 XSS 代码（服务器中没有这样的页面和内容），一般容易出现在**搜索页面**。

### 存储型 XSS

<持久化>

代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种 XSS 非常危险，容易造成蠕虫，大量盗窃 cookie（虽然还有种 DOM 型 XSS，但是也还是包括在存储型 XSS 内）。

### DOM 型 XSS

基于文档对象模型（Document Objeet Model，DOM）的一种漏洞。DOM 是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM 中有很多对象，其中一些是用户可以操纵的，如 uRI ，location，refelTer 等。客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得 DOM 中的数据在本地执行，如果 DOM 中的数据没有经过严格确认，就会产生 DOM XSS 漏洞。

### XSS 解决方法：

转义单引号，双引号，尖括号等特殊字符，可以采用 htmlencode 编码 或者过滤掉这些特殊字符，恶意代码当然也就没法执行了

## CSRF，跨站请求伪造(Cross-site request forgery)

发起 CSRF 攻击的三个必要条件：

1. 目标站点一定要有 CSRF 漏洞；

2. 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；

3. 需要用户打开一个第三方站点，如黑客的站点等。

Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。

### CSRF 解决方法

1. 充分利用好 Cookie 的 SameSite 属性。


    SameSite 选项通常有 Strict、Lax 和 None 三个值。

    SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。

    Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。

    而如果使用 None 的话，在任何情况下都会发送 Cookie 数据

2. 验证请求的来源站点

   在服务器端验证请求来源的站点，就是验证 HTTP 请求头中的 Origin 和 Referer 属性。

3. 在请求地址中添加 token 并验证

   CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。因此要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

## SQL 注入

拼接 SQL 时未仔细过滤，黑客可提交畸形数据改变语义。比如查某个文章，提交了这样的数据 id=-1 or 1=1 等。1=1 永远是 true，导致 where 语句永远是 ture.那么查询的结果相当于整张表的内容，攻击者就达到了目的。或者，通过屏幕上的报错提示推测 SQL 语句等。

### SQL 注入解决方案

预防策略：

1. 禁止目标网站利用动态拼接字符串的方式访问数据库

2. 减少不必要的数据库抛出的错误信息

3. 对数据库的操作赋予严格的权限控制

4. 净化和过滤掉不必要的 SQL 保留字，比如：where, or, exec 等

## 点击劫持

1. 诱使用户点击看似无害的按钮（实则点击了透明 iframe 中的按钮）.

2. 监听鼠标移动事件，让危险按钮始终在鼠标下方.

3. 使用 HTML5 拖拽技术执行敏感操作（例如 deploy key）.

### 点击劫持解决方案

1. 服务端添加 `X-Frame-Options` 响应头,这个 HTTP 响应头是为了防御用 iframe 嵌套的点击劫持攻击。这样浏览器就会阻止嵌入网页的渲染。

2. JS 判断顶层视口的域名是不是和本页面的域名一致，不一致则不允许操作，`top.location.hostname === self.location.hostname`；

3. 敏感操作使用更复杂的步骤（验证码、输入项目名称以删除）。

## window.opener 安全问题

window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target="\_blank" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。

一般来说，打开同源(域名相同)的页面，不会有什么问题。但对于跨域的外部链接来说，存在一个被钓鱼的风险。比如你正在浏览购物网站，从当前网页打开了某个外部链接，在打开的外部页面，可以通过 window.opener.location 改写来源站点的地址。利用这一点，将来源站点改写到钓鱼站点页面上，例如跳转到伪造的高仿购物页面，当再回到购物页面的时候，是很难发现购物网站的地址已经被修改了的，这个时候你的账号就存在被钓鱼的可能了。

### 解决方案

1. 设置 rel 属性

   ```html
   <a href="https://xxxx" rel="noopener noreferrer"> 外链 <a></a></a>
   ```

   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。

2. 将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，再由服务器 redirect 到外链。

3. 可以由 widow.open 打开外链。

## 文件上传漏洞

服务器未校验上传的文件，致使黑客可以上传恶意脚本等方式。

### 文件上传漏洞预防策略

1. 用文件头来检测文件类型，使用白名单过滤(有些文件可以从其中一部分执行，只检查文件头无效，例如 PHP 等脚本语言)；

2. 上传后将文件彻底重命名并移动到不可执行的目录下；

3. 升级服务器软件以避免路径解析漏洞；

4. 升级用到的开源编辑器；

5. 管理后台设置强密码。

## 参考资源

- [Web 安全总结(面试必备良药)](https://mp.weixin.qq.com/s/wUPbypi3Ewa-yKhp3ZoEaw)
