# 浏览器有哪些进程和线程

## 浏览器中的线程

- GUI 渲染线程（呈现引擎）

  负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

- JS 引擎线程

  也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）JS 引擎线程负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

- 浏览器事件触发线程

  当一个事件被触发时该线程会把事件处理内容添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理；

- 定时触发器线程

  浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案；

- 异步 HTTP 请求线程

  在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；

### Promise 事件例子

这个例子是我根据结果猜想的，Promise 是否通过事件线程进行转发到执行队列？

```js
new Promise((resolve) => {
  setTimeout(() => {
    console.log('s:1');
    Promise.resolve().then(() => {
      console.log('p:1');
    });
    resolve(true);
    console.log('s:2');
  }, 1000);
}).then(() => console.log('p:2'));
```

打印顺序为 `s:1, s:2, p:1, p2`

分析：

1. JS 执行向下，遇到 Promise 构造进入参数内部继续执行
2. 发现 setTimeout 调用，将事件注册到定时器线程，回调注册到事件线程
3. 发现 then 方法注册的回调用，将其注册到事件线程
4. 1s 后，定时器线程触发，通知事件线程，事件线程将任务加入到执行队列
5. JS 取出队列中的定时器任务继续执行，打印 `s:1`，继续执行，发现 Promise.resolve 调用，直接将注册和状态改变一起通知给事件线程，事件线程将新任务加入执行队列
6. JS 执行到 resolve(true)，通知事件线程，事件线程将对应的事件回调加入执行队列，清除注册，此时执行队列存在 2 个任务
7. 打印 `s:2`
8. JS 依次从队列中取出 p1 和 p2 任务，分别执行相继打印 `p:1`和`p:2`


## 进程关系

以 Blink 为例

Blink 中采用了多进程架构，它的优点如下

- 避免单个 page crash 影响整个浏览器
- 避免第三方插件 crash 影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

Blink 中包含的主要进程如下

- Browser 进程：主进程，只有一个。它的作用有

  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等

- Renderer 进程：默认每个页面一个，互不影响。主要作用为解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU 进程：最多一个，用于 3D 绘制等

Browser 和 Renderer 通信过程

1. Browser 进程收到用户请求，首先 UI 线程处理，转交给 IO 线程，随后通过 RendererHost 接口转交给 Renderer 进程
2. Renderer 进程的 Renderer 接口收到消息，IO 线程简单处理后，交给渲染线程，进行 HTML 解析和 DOM 树构建，CSS 解析，JS 执行，RenderObject 树构建，布局和绘制等过程，生成用户可见区域（ViewPort）的 Bitmap。最后通过共享内存方式 IPC 给 Browser 进程
3. Browser 进程使用 Bitmap 内存在界面上绘制出图像。

<br/>
<br/>
<br/>
<Vssue :title="$title" />
  