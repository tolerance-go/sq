# JS 如何进行内存空间管理

## JS 的内存生命周期是什么

1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

JavaScript 有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用 a = null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

## 内存回收方式

JavaScript 有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。

- 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。

- 以 Google 的 V8 引擎为例，在 V8 引擎中所有的 JAVASCRIPT 对象都是通过堆来进行内存分配的。当我们在代码中声明变量并赋值时，V8 引擎就会在堆内存中**分配**一部分给这个变量。如果已申请的内存不足以存储这个变量时，V8 引擎就会继续**申请内存**，直到堆的大小达到了 V8 引擎的内存上限为止（默认情况下，V8 引擎的堆内存的大小上限在 64 位系统中为 1464MB，在 32 位系统中则为 732MB）。

- 另外，V8 引擎对堆内存中的 JAVASCRIPT 对象进行分代管理。

  - 新生代：新生代即存活周期较短的 JAVASCRIPT 对象，如临时变量、字符串等；

  - 老生代：老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

  对于不同代的内存所采取的回收方式也不同，新生代会开辟 2 块一样大小的内存来回复制，老年代则采取标记清除和内存回收，它们的回收频率也不同，新生代因为回收率高所以频率也就比老年代高很多

## 垃圾回收算法

对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。

- 引用计数（现代浏览器不再使用）
- 标记清除（常用）

### 引用计数

引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。

引用计数有一个致命的问题，那就是循环引用

如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。

```ts
function cycle() {
  var o1 = {};
  var o2 = {};
  o1.a = o2;
  o2.a = o1;

  return 'cycle reference!';
}

cycle();
```

cycle 函数执行完成之后，对象 o1 和 o2 实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。

### 标记清除（常用）

标记清除算法（Mark-and-sweep）将“不再使用的对象”定义为“无法到达的对象”。即从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。由以下几步组成：

1. 垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；

2. 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。

3. 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。

无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。

现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。

## 参考资源

- [JavaScript 内存机制](https://www.cnblogs.com/liangyin/p/7764232.html)

<br/>
<br/>
<br/>
<ContributorsList />
<br/>
<br/>
<br/>
<Vssue :title="$title" />
